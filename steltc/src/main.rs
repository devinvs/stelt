use std::collections::{HashMap, VecDeque};
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::Command;

use stelt::gen_impl_map;
use stelt::Lexer;
use stelt::MIRTree;
use stelt::Module;
use stelt::Program;
use stelt::TypeChecker;

use clap::Parser;

#[derive(Parser, Debug)]
#[command(version, about,  long_about = None)]
struct Cli {
    /// verbose logging
    #[arg(short, long, default_value_t = false)]
    verbose: bool,
    /// output directory for build artifacts, defaults to ./build
    #[arg(short, long, value_name = "OUTDIR")]
    outdir: Option<PathBuf>,
    /// program file to compile
    file: PathBuf,
}

fn main() {
    let cli = Cli::parse();

    let path = cli.file;
    let outdir = cli.outdir.unwrap_or(PathBuf::from("./build"));
    let outf = outdir.join(path.file_stem().unwrap());

    let objs = compile(path, outdir.clone());
    let bc = llvmlink(objs);
    let opt = optimize(bc, 3);
    let obj = assemble(opt, 3);
    let _bin = link(vec![obj], outf);
}

fn parse(path: &Path) -> Program {
    let mut file = File::open(path).unwrap();
    let mut buf = String::with_capacity(file.metadata().unwrap().len() as usize);
    file.read_to_string(&mut buf).unwrap();
    parse_str(&buf, &path.into())
}

fn parse_str(s: &str, file: &PathBuf) -> Program {
    // Lex
    let mut lexer = Lexer::default();
    let mut tokens = match lexer.lex(s, file) {
        Ok(t) => {
            if t.check() {
                t
            } else {
                std::process::exit(1);
            }
        }
        Err(t) => {
            t.check();
            std::process::exit(1);
        }
    };

    // Parse
    let program = match Program::parse(&mut tokens) {
        Ok(p) => p,
        Err(e) => {
            eprintln!("{e}");
            std::process::exit(1);
        }
    };

    program
}

fn compile(path: PathBuf, outdir: PathBuf) -> Vec<PathBuf> {
    // Base directory of file path
    let parent = path.parent().unwrap();
    let mod_name = path.file_stem().unwrap().to_str().unwrap().to_string();

    // map of module names to their parse trees
    let mut trees = HashMap::new();

    // map of module name to module interface
    let mut modules = HashMap::new();

    // queue of modules to be parsed
    let mut mod_queue = VecDeque::new();
    mod_queue.push_back(mod_name.clone());

    // also build the order that we resolve, should
    // be the opposite of parsing
    let mut resolve_queue = VecDeque::new();

    // Parse each file using a breadth first search technique, using imported
    // namespace names to locate the source file corresponding to the namespace
    while !mod_queue.is_empty() {
        let name = mod_queue.pop_front().unwrap();
        resolve_queue.push_front(name.clone());

        let path = parent.join(Path::new(&format!("{}.st", name.replace(".", "/"))));

        let mut tree = parse(&path);

        // queue up other modules to be compiled
        for ns in tree.imports.iter() {
            if !trees.contains_key(ns) && !mod_queue.contains(ns) {
                mod_queue.push_back(ns.to_string());
            }
        }

        modules.insert(name.clone(), tree.canonicalize(&name));
        trees.insert(name, tree);
    }

    // Actually Handle imports
    while let Some(name) = resolve_queue.pop_front() {
        // Find the tree, resolve it, add to resolved
        let tree = trees.get_mut(&name).unwrap();
        tree.resolve(&name, &modules);
    }

    // Aggregate the impls
    let impl_map = gen_impl_map(&modules, &trees);

    // Resolve namespace references and convert to mir
    let mut modules_mir = HashMap::new();
    for (name, tree) in trees {
        let tree = MIRTree::from(tree, &modules);
        modules_mir.insert(name, tree);
    }

    let mut artifacts = vec![];

    // Now compile :)
    for (name, mut mir) in modules_mir.into_iter() {
        let mut checker = TypeChecker::default();
        match checker.check_program(&mut mir, &impl_map) {
            Ok(_) => {}
            Err(e) => {
                eprintln!("{e}");
                std::process::exit(1);
            }
        }

        let mir = mir.with_concrete_types(&impl_map, &modules);
        let lir = mir.lower(&impl_map);

        let out_path = outdir.join(Path::new(&format!("{}.ll", name)));
        artifacts.push(PathBuf::from(&out_path));

        let out = File::create(out_path).unwrap();
        let mut module = Module::new(Box::new(out));

        let main = if name == mod_name {
            Some(format!("{name}/main"))
        } else {
            None
        };

        module.compile(lir, main).unwrap();
    }

    // return list of artifacts generated by this compilation step
    artifacts
}

fn optimize(p: PathBuf, level: u8) -> PathBuf {
    let out_p = PathBuf::from("./build/out.opt.bc");

    let fin = p.to_str().unwrap();
    let fout = out_p.to_str().unwrap();
    let opt = format!("-O{level}");

    let stat = Command::new("opt")
        .args([&opt, fin, "-o", fout])
        .status()
        .unwrap();

    if !stat.success() {
        eprintln!("opt failed with exit code: {stat}");
        std::process::exit(1);
    }

    out_p
}

fn assemble(p: PathBuf, level: u8) -> PathBuf {
    let out_p = p.with_extension("o");
    let fin = p.to_str().unwrap();
    let opt = format!("-O{level}");

    let stat = Command::new("llc")
        .args(["--relocation-model=pic", "-filetype=obj", &opt, fin])
        .status()
        .unwrap();

    if !stat.success() {
        eprintln!("llc failed with exit code: {stat}");
        std::process::exit(1);
    }

    out_p
}

fn llvmlink(objs: Vec<PathBuf>) -> PathBuf {
    let outp = PathBuf::from("./build/out.all.bc");
    let fout = outp.to_str().unwrap();
    let stat = Command::new("llvm-link")
        .args(["-o", fout])
        .args(objs)
        .status()
        .unwrap();

    if !stat.success() {
        eprintln!("llvm-link failed with exit code: {stat}");
        std::process::exit(1);
    }

    outp
}

fn link(objs: Vec<PathBuf>, outp: PathBuf) {
    let fout = outp.to_str().unwrap();

    // what a massive compromise, i need to look into linkers and how to properly exit
    // without all this libc garbage. maybe rust or zig does something interesting
    // let stat = Command::new("mold")
    //     .args([
    //         "--hash-style=gnu",
    //         "--build-id",
    //         "--eh-frame-hdr",
    //         "-m",
    //         "elf_x86_64",
    //         "-pie",
    //         "-dynamic-linker",
    //         "/lib64/ld-linux-x86-64.so.2",
    //     ])
    //     .args(["-o", fout])
    //     .args([
    //         "/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib64/Scrt1.o",
    //         "/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib64/crti.o",
    //         "/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/crtbeginS.o",
    //         "-L/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1",
    //         "-L/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib64",
    //         "-L/lib/../lib64 -L/usr/lib/../lib64",
    //         "-L/lib",
    //         "-L/usr/lib",
    //     ])
    //     .args(objs)
    //     .args([
    //         "-lgcc",
    //         "--as-needed",
    //         "-lgcc_s",
    //         "--no-as-needed",
    //         "-lc",
    //         "-lgcc",
    //         "--as-needed",
    //         "-lgcc_s",
    //         "--no-as-needed",
    //         "/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/crtendS.o",
    //         "/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/14.2.1/../../../../lib64/crtn.o",
    //     ])
    //     .status()
    //     .unwrap();

    let stat = Command::new("clang")
        .args(["-flto", "-o", fout])
        .args(objs)
        .status()
        .unwrap();

    if !stat.success() {
        eprintln!("mold failed with exit code: {stat}");
        std::process::exit(1);
    }
}
